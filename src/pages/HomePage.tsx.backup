import { useState, useEffect, useRef } from "react";
import FantasyButton from "../components/FantasyButton";
import BiomeEffectsOverlay from "../components/BiomeEffectsOverlay";
import TotemGlitch from "../components/effects/TotemGlitch";
import { Link } from "react-router-dom";

function HomePage() {
  const [isInside, setIsInside] = useState(false);
  const [activeVideoIndex, setActiveVideoIndex] = useState(0);
  const [nextVideoIndex, setNextVideoIndex] = useState(1);
  const [showPlayerB, setShowPlayerB] = useState(false);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [glitchTotem, setGlitchTotem] = useState(false);
  const [glitchVideoIndex, setGlitchVideoIndex] = useState(0);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(
    () =>
      typeof window !== "undefined" && Boolean(localStorage.getItem("token")),
  );
  const [showFooterVariant, setShowFooterVariant] = useState(false);
  const playerARef = useRef<HTMLVideoElement>(null);
  const playerBRef = useRef<HTMLVideoElement>(null);
  const peekARef = useRef<HTMLVideoElement>(null);
  const peekBRef = useRef<HTMLVideoElement>(null);

  const isMobile =
    typeof window !== "undefined" &&
    window.matchMedia("(max-width: 768px)").matches;

  const biomeVideos = [
    "/landingpage/1.webm",
    "/landingpage/2.webm",
    "/landingpage/3.webm",
    "/landingpage/4.webm",
    "/landingpage/5.webm",
    "/landingpage/6.webm",
  ];

  useEffect(() => {
    const id = requestAnimationFrame(() => {
      // Page ready to render
    });
    return () => cancelAnimationFrame(id);
  }, []);

  useEffect(() => {
    let startY = 0;

    const htmlEl = document.documentElement;
    const bodyEl = document.body;
    const previousHtmlOverscroll = htmlEl.style.overscrollBehaviorY;
    const previousBodyOverscroll = bodyEl.style.overscrollBehaviorY;
    const previousHtmlTouchAction = htmlEl.style.touchAction;
    const previousBodyTouchAction = bodyEl.style.touchAction;

    if (isMobile) {
      htmlEl.style.overflow = "hidden";
      bodyEl.style.overflow = "hidden";
      htmlEl.style.touchAction = "none";
      bodyEl.style.touchAction = "none";
    }

    htmlEl.style.overscrollBehaviorY = "none";
    bodyEl.style.overscrollBehaviorY = "none";

    const onTouchStart = (event: TouchEvent) => {
      if (event.touches.length !== 1) return;
      startY = event.touches[0].clientY;
    };

    const onTouchMove = (event: TouchEvent) => {
      if (isMobile) {
        event.preventDefault();
        return;
      }

      if (event.touches.length !== 1) return;
      const currentY = event.touches[0].clientY;
      const isPullingDown = currentY > startY;
      const scrollTop = document.scrollingElement?.scrollTop ?? window.scrollY;

      if (isPullingDown && scrollTop <= 0) {
        event.preventDefault();
      }
    };

    window.addEventListener("touchstart", onTouchStart, { passive: true });
    window.addEventListener("touchmove", onTouchMove, { passive: false });

    return () => {
      window.removeEventListener("touchstart", onTouchStart);
      window.removeEventListener("touchmove", onTouchMove);
      htmlEl.style.overscrollBehaviorY = previousHtmlOverscroll;
      bodyEl.style.overscrollBehaviorY = previousBodyOverscroll;
      htmlEl.style.touchAction = previousHtmlTouchAction;
      bodyEl.style.touchAction = previousBodyTouchAction;
    };
  }, [isMobile]);

  useEffect(() => {
    const syncAuth = () => {
      setIsAuthenticated(
        typeof window !== "undefined" && Boolean(localStorage.getItem("token")),
      );
    };

    syncAuth();
    window.addEventListener("storage", syncAuth);
    window.addEventListener("focus", syncAuth);

    return () => {
      window.removeEventListener("storage", syncAuth);
      window.removeEventListener("focus", syncAuth);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(() => {
      setShowFooterVariant((prev) => !prev);
    }, 4000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const maskRadius = isMobile ? 150 : 350;

    const handlePointerMove = (e: PointerEvent) => {
      document.documentElement.style.setProperty("--mask-x", `${e.clientX}px`);
      document.documentElement.style.setProperty("--mask-y", `${e.clientY}px`);
      document.documentElement.style.setProperty(
        "--mask-radius",
        `${maskRadius}px`,
      );
      setIsInside(true);
    };

    const handlePointerLeave = () => {
      setIsInside(false);
    };

    window.addEventListener("pointermove", handlePointerMove, {
      passive: true,
    });
    window.addEventListener("pointerleave", handlePointerLeave, {
      passive: true,
    });
    return () => {
      window.removeEventListener("pointermove", handlePointerMove);
      window.removeEventListener("pointerleave", handlePointerLeave);
    };
  }, [isMobile]);

  useEffect(() => {
    if (isMobile) {
      const maskRadius = 150;
      let rafId: number | null = null;

      const updateMaskPosition = (clientX: number, clientY: number) => {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
        }

        rafId = requestAnimationFrame(() => {
          document.documentElement.style.setProperty(
            "--mask-x",
            `${clientX}px`,
          );
          document.documentElement.style.setProperty(
            "--mask-y",
            `${clientY}px`,
          );
          document.documentElement.style.setProperty(
            "--mask-radius",
            `${maskRadius}px`,
          );
          setIsInside(true);
          rafId = null;
        });
      };

      const handleTouchStart = (e: TouchEvent) => {
        if (e.touches[0]) {
          updateMaskPosition(e.touches[0].clientX, e.touches[0].clientY);
        }
      };

      const handleTouchMove = (e: TouchEvent) => {
        if (e.touches[0]) {
          updateMaskPosition(e.touches[0].clientX, e.touches[0].clientY);
        }
      };

      const handleTouchEnd = () => {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        setIsInside(false);
      };

      window.addEventListener("touchstart", handleTouchStart, {
        passive: true,
      });
      window.addEventListener("touchmove", handleTouchMove, {
        passive: true,
      });
      window.addEventListener("touchend", handleTouchEnd, {
        passive: true,
      });
      window.addEventListener("touchcancel", handleTouchEnd, {
        passive: true,
      });

      return () => {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
        }
        window.removeEventListener("touchstart", handleTouchStart);
        window.removeEventListener("touchmove", handleTouchMove);
        window.removeEventListener("touchend", handleTouchEnd);
        window.removeEventListener("touchcancel", handleTouchEnd);
      };
    }
  }, [isMobile]);

  useEffect(() => {
    const handleParallaxMove = (e: PointerEvent | TouchEvent) => {
      let clientX: number | undefined;

      if ("touches" in e) {
        clientX = e.touches[0]?.clientX;
      } else {
        clientX = e.clientX;
      }

      if (typeof clientX !== "number") return;

      const x = (clientX / window.innerWidth - 0.5) * 16;
      document.documentElement.style.setProperty("--parallax-x", `${x}px`);
    };

    document.documentElement.style.setProperty("--parallax-x", "0px");
    window.addEventListener("pointermove", handleParallaxMove, {
      passive: true,
    });
    window.addEventListener("touchmove", handleParallaxMove, {
      passive: true,
    });

    return () => {
      window.removeEventListener("pointermove", handleParallaxMove);
      window.removeEventListener("touchmove", handleParallaxMove);
    };
  }, []);

  const triggerTransition = () => {
    if (isTransitioning) return;

    const visibleIndex = showPlayerB ? nextVideoIndex : activeVideoIndex;
    const upcomingIndex = (visibleIndex + 1) % biomeVideos.length;
    const previousIndex =
      (visibleIndex - 1 + biomeVideos.length) % biomeVideos.length;

    setIsTransitioning(true);
    setGlitchTotem(true);
    setGlitchVideoIndex(previousIndex);

    // PRELOAD hidden player FIRST
    if (showPlayerB) {
      setActiveVideoIndex(upcomingIndex);
      prepareNextVideo(upcomingIndex, playerARef.current);
    } else {
      setNextVideoIndex(upcomingIndex);
      prepareNextVideo(upcomingIndex, playerBRef.current);
    }

    // Wait 2 frames for decode
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        setShowPlayerB((prev) => !prev); // instant cut behind glitch
      });
    });

    setTimeout(() => {
      setGlitchTotem(false);
      setIsTransitioning(false);
    }, 500);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      triggerTransition();
    }, 8000);

    return () => clearInterval(interval);
  }, [isTransitioning]);

  const handleTotemClick = () => {
    triggerTransition();
  };

  const prepareNextVideo = (index: number, ref: HTMLVideoElement | null) => {
    if (!ref) return;
    ref.src = biomeVideos[index];
    ref.load();
    ref.play().catch(() => {});
  };

  return (
    <main className="fixed inset-0 w-full h-full overflow-hidden">
      <svg className="absolute inset-0 w-0 h-0 pointer-events-none">
        <defs>
          <filter id="biomeDistortion">
            <feTurbulence
              type="fractalNoise"
              baseFrequency="0.02"
              numOctaves="4"
              result="noise"
            >
              <animate
                attributeName="baseFrequency"
                values="0.02;0.03;0.02"
                dur="0.8s"
                repeatCount="1"
              />
            </feTurbulence>
            <feDisplacementMap
              in="SourceGraphic"
              in2="noise"
              scale="40"
              xChannelSelector="R"
              yChannelSelector="G"
              result="displaced"
            >
              <animate
                attributeName="scale"
                values="40;60;40"
                dur="0.8s"
                repeatCount="1"
              />
            </feDisplacementMap>
          </filter>
        </defs>
      </svg>

      <style>
        {`
        /* Hide iOS video controls */
        video::-webkit-media-controls-panel, 
        video::-webkit-media-controls-play-button, 
        video::-webkit-media-controls-start-playback-button {
          display: none !important;
          -webkit-appearance: none;
        }

        @keyframes radialPulse {
          0% {
            filter: brightness(1) drop-shadow(0 0 0px rgba(251, 191, 36, 0));
          }
          50% {
            filter: brightness(1.1) drop-shadow(0 0 40px rgba(251, 191, 36, 0.5));
          }
          100% {
            filter: brightness(1) drop-shadow(0 0 0px rgba(251, 191, 36, 0));
          }
        }

        .bg-corner-slice {
  position: absolute;
  width: 60%;
  height: 40%;
  overflow: hidden;

  mix-blend-mode: screen;
  opacity: 0.35;

  filter: blur(0.7px);

  animation: bgSliceGlitch 0.18s steps(1, end) 1;
  will-change: transform, filter;
}

@keyframes bgSliceGlitch {
  0% {
    transform: translate(0, 0) scaleY(1);
    filter: none;
  }

  35% {
    transform: translate(-4px, -1px) scaleY(1.03);
    filter: drop-shadow(-2px 0 rgba(130, 70, 190, 0.45));
  }

  65% {
    transform: translate(3px, 1px) scaleY(0.97);
    filter: drop-shadow(2px 0 rgba(255, 255, 255, 0.35));
  }

  100% {
    transform: translate(0, 0) scaleY(1);
    filter: none;
  }
}

@keyframes glitchFlicker {
  0% {
    transform: translate3d(0, 0, 0);
    filter: none;
  }
  20% {
    transform: translate3d(-2px, 1px, 0);
    filter: contrast(1.1) saturate(1.2);
  }
  40% {
    transform: translate3d(2px, -1px, 0);
    filter: contrast(1.2) saturate(1.3);
  }
  60% {
    transform: translate3d(-1px, 2px, 0);
    filter: contrast(1.1) saturate(1.2);
  }
  80% {
    transform: translate3d(1px, -2px, 0);
    filter: contrast(1.2) saturate(1.3);
  }
  100% {
    transform: translate3d(0, 0, 0);
    filter: none;
  }
}

.glitch-layer--active {
  animation: glitchFlicker 0.5s steps(1, end) 1;
}

@keyframes glitchJitter {
  0% {
    transform: translate3d(0, 0, 0);
  }
  25% {
    transform: translate3d(-4px, 2px, 0);
  }
  50% {
    transform: translate3d(4px, -2px, 0);
  }
  75% {
    transform: translate3d(-2px, -3px, 0);
  }
  100% {
    transform: translate3d(0, 0, 0);
  }
}

.glitch-video {
  mix-blend-mode: normal;
}

.glitch-layer--active .glitch-video {
  mix-blend-mode: screen;
  opacity: 0.85;
  filter: contrast(1.2) saturate(1.4) hue-rotate(6deg);
  animation: glitchJitter 0.5s steps(1, end) 1;
}

  `}
      </style>
      <div
        className="absolute inset-0 w-full h-full"
        style={{
          zIndex: 10,
          transform: `translateX(var(--parallax-x)) scale(${isMobile ? 1.1 : 1.02})`,
          animation: "radialPulse 3s ease-in-out infinite",
        }}
      >
        {/* PLAYER A */}
        <video
          ref={playerARef}
          src={biomeVideos[activeVideoIndex]}
          className={`absolute inset-0 w-full h-full object-cover pointer-events-none transition-opacity duration-0 ${
            showPlayerB ? "opacity-0" : "opacity-100"
          }`}
          autoPlay
          muted
          loop
          playsInline
          preload="auto"
          disableRemotePlayback
          controls={false}
          aria-hidden
        />

        {/* PLAYER B */}
        <video
          ref={playerBRef}
          src={biomeVideos[nextVideoIndex]}
          className={`absolute inset-0 w-full h-full object-cover pointer-events-none transition-opacity duration-0 ${
            showPlayerB ? "opacity-100" : "opacity-0"
          }`}
          autoPlay
          muted
          loop
          playsInline
          preload="auto"
          disableRemotePlayback
          controls={false}
          aria-hidden
        />
      </div>

      {/* Hover Peek Overlay - Reveals the alternate video */}
      {!isTransitioning && (
        <div
          className="absolute inset-0 w-full h-full pointer-events-none"
          style={{
            transform: `translateX(var(--parallax-x)) scale(${isMobile ? 1.1 : 1.02})`,
            animation: "radialPulse 3s ease-in-out infinite",
            maskImage: !isInside
              ? "none"
              : "radial-gradient(circle var(--mask-radius) at var(--mask-x) var(--mask-y), transparent 0%, transparent 45%, rgba(0,0,0,0.7) 65%, black 85%)",
            WebkitMaskImage: !isInside
              ? "none"
              : "radial-gradient(circle var(--mask-radius) at var(--mask-x) var(--mask-y), transparent 0%, transparent 45%, rgba(0,0,0,0.7) 65%, black 85%)",
            maskSize: "cover",
            WebkitMaskSize: "cover",
            maskPosition: "center",
            WebkitMaskPosition: "center",
            zIndex: 20,
          }}
        >
          {/* Show the opposite player - always render both for synced playback */}
          <video
            ref={peekARef}
            src={biomeVideos[activeVideoIndex]}
            className={`absolute inset-0 w-full h-full object-cover pointer-events-none ${
              showPlayerB ? "opacity-100" : "opacity-0"
            }`}
            autoPlay
            muted
            loop
            playsInline
            preload="auto"
            disableRemotePlayback
            controls={false}
            aria-hidden
          />
          <video
            ref={peekBRef}
            src={biomeVideos[nextVideoIndex]}
            className={`absolute inset-0 w-full h-full object-cover pointer-events-none ${
              showPlayerB ? "opacity-0" : "opacity-100"
            }`}
            autoPlay
            muted
            loop
            playsInline
            preload="auto"
            disableRemotePlayback
            controls={false}
            aria-hidden
          />
        </div>
      )}
      {/* Biome Effects Overlay */}
      <BiomeEffectsOverlay
        biomeIndex={showPlayerB ? nextVideoIndex : activeVideoIndex}
        isTransitioning={isTransitioning}
      />

      {isInside && (
        <div
          className="pointer-events-none fixed"
          style={{
            left: "var(--mask-x)",
            top: "var(--mask-y)",
            width: "300px",
            height: "300px",
            transform: "translate(-50%, -50%)",
            background:
              "radial-gradient(circle, rgba(251, 191, 36, 0.15) 0%, transparent 70%)",
            filter: "blur(20px)",
            transition: "none",
          }}
        />
      )}

      {/* Glitch Overlay (Persistent, Not Mounted) - Shows during transitions */}
      <div
        className={`fixed inset-0 z-30 pointer-events-none transition-opacity duration-75 ${
          glitchTotem ? "opacity-100 glitch-layer--active" : "opacity-0"
        }`}
      >
        <video
          src={biomeVideos[glitchVideoIndex]}
          autoPlay
          muted
          loop
          playsInline
          className="absolute inset-0 w-full h-full object-cover glitch-video"
          style={{
            transform: `translateX(var(--parallax-x)) scale(${isMobile ? 1.1 : 1.02})`,
            filter: "url(#biomeDistortion)",
          }}
          disableRemotePlayback
          controls={false}
          aria-hidden
        />
      </div>

      <div
        className="absolute left-1/2 top-0 
             -translate-x-1/2 pt-8 
             pointer-events-none"
        style={{ zIndex: 40 }}
      >
        <img
          src="/landingpage/Incrideaici.webp"
          alt="Incridea ICI Logo"
          className="h-20 md:h-20 w-auto"
          decoding="async"
        />
      </div>

      <div
        className="absolute left-1/2 top-1/2 
             -translate-x-1/2 -translate-y-1/2 
             pointer-events-none"
        style={{ zIndex: 50, height: "70vh", maxHeight: "700px" }}
      >
        <div
          className="h-full flex items-center justify-center"
          style={{
            transform: `translateX(var(--parallax-x))`,
            transition: "transform 0.25s ease-out",
          }}
        >
          <TotemGlitch src="/landingpage/totem.webp" active={glitchTotem} />
        </div>
      </div>

      <button
        onClick={handleTotemClick}
        className="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 w-24 bg-transparent cursor-pointer hover:bg-white/5 transition-colors duration-300 rounded-lg"
        style={{
          zIndex: 100,
          height: "70vh",
          maxHeight: "700px",
        }}
        aria-label="Click to swap biomes"
      />

      <div
        className="absolute left-1/2 bottom-[16%] md:bottom-[14%] -translate-x-1/2 flex items-center gap-4 sm:gap-6 md:gap-8 lg:gap-12"
        style={{ zIndex: 60 }}
      >
        <FantasyButton to="/events">Events</FantasyButton>
        <FantasyButton
          to={isAuthenticated ? "/profile" : "/login"}
          variant="amber"
        >
          {isAuthenticated ? "Profile" : "Login"}
        </FantasyButton>
      </div>

      <footer
        className="absolute bottom-0 left-0 w-full px-4 py-6 text-center bg-gradient-to-t from-black/80 to-transparent"
        style={{ zIndex: 90 }}
      >
        <div
          className="absolute inset-0 flex items-center justify-center"
          style={{
            opacity: showFooterVariant ? 0 : 1,
            transition: "opacity 0.5s ease-in-out",
            pointerEvents: showFooterVariant ? "none" : "auto",
          }}
        >
          <nav className="flex flex-wrap justify-center gap-2 sm:gap-3 text-[10px] sm:text-xs text-gray-300 font-medium">
            <Link
              to="/privacy"
              className="text-gray-300 visited:text-gray-300 active:text-gray-300 no-underline hover:text-gray-100 transition-colors duration-200"
            >
              Privacy Policy
            </Link>
            <span className="text-gray-300">|</span>
            <Link
              to="/terms"
              className="text-gray-300 visited:text-gray-300 active:text-gray-300 no-underline hover:text-gray-100 transition-colors duration-200"
            >
              Terms & Conditions
            </Link>
            <span className="text-gray-300">|</span>
            <Link
              to="/guidelines"
              className="text-gray-300 visited:text-gray-300 active:text-gray-300 no-underline hover:text-gray-100 transition-colors duration-200"
            >
              Guidelines
            </Link>
            <span className="text-gray-300">|</span>
            <Link
              to="/refund"
              className="text-gray-300 visited:text-gray-300 active:text-gray-300 no-underline hover:text-gray-100 transition-colors duration-200"
            >
              Refund Policy
            </Link>
            <span className="text-gray-300">|</span>
            <Link
              to="/contact"
              className="text-gray-300 visited:text-gray-300 active:text-gray-300 no-underline hover:text-gray-100 transition-colors duration-200"
            >
              Contact Us
            </Link>
          </nav>
        </div>

        <div
          className="absolute inset-0 flex items-center justify-center"
          style={{
            opacity: showFooterVariant ? 1 : 0,
            transition: "opacity 0.5s ease-in-out",
            pointerEvents: showFooterVariant ? "auto" : "none",
          }}
        >
          <p className="text-[10px] sm:text-xs text-gray-300 font-medium">
            Made with <span className="text-gray-400">❤</span> by Technical Team
            <br />© Incridea 2026
          </p>
        </div>
      </footer>
    </main>
  );
}

export default HomePage;
